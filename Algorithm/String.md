# String



## 문자의 표현

### ASCII

> - ASCII(American Standard Code for Information Interchange)
> - 7bit 인코딩, 128문자, 33개의 출력불가능한 제어문자, 95개의 출력가능한 문자

### 확장 아스키

> - 아스키, 도형, 특수문자, 기호 등 부가적인 문자 128개 추가
> - 1B 8bit 모두 사용
> - 컴퓨터 생산자와 소프트웨어 개발자가 문자를 할당하므로 서로 다른 프로그램이나 컴퓨터간 교환X

### 유니코드

> - 국가간 동일한 코드체계를 위함
>
> - Character Set
>
>   > - UCS-2 (Universal Character Set 2)
>   > - UCS-4 (Universal Character Set 4)
>   > - 유니코드를 저장하는 변수의 크기 정의
>   > - 바이트 순서에 대한 표준화X
>
> - 유니코드 인코딩 UTF (Unicode Transformation Format)
>
>   > - UTF-8 (in web) : 8bit ~ 32bit, 1 Byte * 4
>   > - UTF-16 (in windows, java) : 16bit ~ 32bit, 2 Byte * 2
>   > - UTF-32 (in unix) : 32bit ~ 32bit, 4 Byte * 1

### Python 인코딩

> - 2x 버전: ASCII `#-*- coding: utf-8 -*-` 을 첫 줄에 명시
> - 3x 버전: 유니코드 UTF-8 -생략 가능
> - 인코딩 방식을 다르게 하고 싶으면 첫 줄에 인코딩 방식 지정





## 문자열

### 문자열의 분류

> - 문자열
>
>   > - fixed length
>   >
>   > - variable length
>   >
>   >   > - length controlled: java
>   >   > - delimited: c언어

### JAVA 와 C언어

> #### JAVA
>
> > - 기본 객체 메타 데이터 외에 4가지 필드를 포함
> >
> > - hash, count(문자열길이) offset(문자열 데이터 시작점), value(실제 문자열 배열에 대한 참조)
> >
> > - 문자열 데이터를 저장, 처리하는 클래스 String 제공
> >
> >   ```java
> >   String str="abc";
> >   String str = new String("abc")
> >   ```
> >
> > - 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공
> >
> >   ```java
> >   +, length(), replace(), split(), substring()...
> >   ```
> >
> > - 유니코드(UTF-16, 2byte)로 저장
>
> #### C언어
>
> > - 문자열은 문자들의 배열 형태
> >
> > - 항상 마지막에 끝을 표시하는 \0 널문자를 포함한다.
> >
> > - ```c
> >   char ary[]={'a', 'b', 'c', '\0'};
> >   char ary[]="abc";
> >   ```
> >
> > - 문자열 처리에 필요한 연산을 함수 형태로 제공
> >
> > - ```c
> >   strlen(), strcpy(), strcmp()...
> >   ```
> >
> > - 아스키 코드로 저장
> >
> > - 유니코드(UTF-8)로 저장

### Python

> - char 타입 없음
>
> - 텍스트 데이터의 취급 방법이 통일됨
>
> - ```python
>   a = 'abc'
>   a = "abc"
>   a = 'a'+'bc'  # 'abc'
>   a = 'abc'*3   #'abcabcabc'
>   ```
>
> - 문자열은 시퀀스 자료형으로 분류되어 인덱싱, 슬라이싱 연산 가능
>
>   ```python
>   replace(), split(), isalpha(), find()
>   ```
>
> - immutable(변경 불가능)

## 패턴 매칭

### 브루트포스 Brute Force

> - 문자열을 처음부터 끝까지 차례대로 순회하며 문자들을 일일이 비교
>
> #### 시간복잡도
>
> > - M: 찾을 패턴의 길이
> > - N: 전체 텍스트의 길이
> >
> > - 최악의 경우 O(MN)

### 카프-라빈 알고리즘

### KMP 알고리즘

> - 불일치가 발생한 텍스트의 앞 부분에 대해 비교하지 않고 매칭
> - 패턴을 전처리하여 불일치가 발생할 경우 다음 이동 위치를 구해 잘못된 시작을 최소화
> - 패턴을 못찾을 경우 마지막으로 찾은 곳 다음으로 이동
> - 패턴을 찾을 경우 패턴 길이-1 만틈 앞으로 이동(패턴이 겹치는 경우가 발생할 수도 있기 때문)
>
> #### 시간복잡도
>
> > - O(M+N)
> > - Θ(N) (평균적)

### 보이어-무어 알고리즘

> - 오른쪽에서 왼쪽으로 비교
> - 대부분 상용 소프트웨어에서 채택하는 알고리즘
> - 텍스트의 마지막과 패턴의 오른쪽 끝에 있는 문자가 불일치할 경우, 다음 이동위치를 구할 때 패턴의 길이만큼 이동 가능
>
> #### 시간복잡도
>
> > - 최악의 경우: O(MN)
> > - Ω(N) (최선의 경우)
> > - 일반적으로 O(N)보다 적음

## 문자열 암호화

### 시저 암호(Caesar cipher)

> - 알파벳을 일정 문자 수만큼 평행이동

### 단일 치환 암호

> - 각 알파벳이 1 대 1로 다른 알파벳으로 치환됨
> - 문자 변환표(key space)가 필요
> - 암호키의 총 수: 26 × 25 × 24 × ... × 1 = 26!

### bit열의 암호화

> - 배타적 논리합(exclusive-or) 연산 사용
> - 0과 1에 대해 경우의 수가 2개씩 생기므로 key가 있어야 원문 복원 가능

## 문자열 압축

### Run-length encoding 알고리즘

> - 같은 값이 몇 번 반복되는지를 문자 뒤에 적어서 압축
> - 이미지 파일 BMP 파일 포맷의 압축 방법

### 허프만 코딩 알고리즘