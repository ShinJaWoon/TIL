# List

[알고리즘](#알고리즘)

[배열](#배열)

[정렬](#정렬)

[카운팅 정렬](#카운팅-정렬)

[Baby-gin Game](#baby-gin-game)



<br>





## 알고리즘

### Algorithm

> - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
>
> - 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
>
> - 기준
>
>   > - 정확성
>   > - 작업량
>   > - 메모리 사용량
>   > - 단순성
>   > - 최적성



<br>



### 시간 복잡도

> #### 시간 복잡도(Time Complexity)
>
> > - 실제로 걸리는 시간을 측정
> > - 실행되는 명령문의 개수(연산의 횟수)를 계산 
>
> #### 빅-오(O) 표기법
>
> > - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만 표시
> >
> > - 계수(Coefficient)는 생략
> >
> >   ```markdown
> >   O( 5n + 4 ) = O( 5n ) = O( n )
> >   O( 5n^2 + 4n + 3 ) = O( n^2 )
> >   O( 5 ) = O ( 1 )
> >   ```
> >
> > - 시간 복잡도의 종류
> >
> >   - O(1)
> >   - O(logn)
> >   - O(n)
> >   - O(nlogn)
> >   - O(n^2)
> >   - O(2^n)
> >   - O(n!)





---



<br>

<br> 



## 배열

### 배열

> - 일정한 자료형의 변수를 하나의 이름으로 열거하여 사용
> - 다수의 변수 선언 가능 및 다양한 작업 가능



<br>



### 1차원 배열

>  #### 선언
>
> >  ```python
> >  Arr = list()
> >  Arr = []
> >  
> >  Arr = [1, 2, 3]
> >  Arr = [0] * 10
> >  ```
>
>  #### 접근
>
> >  ```py
> >  Arr[0] = 1  	# 배열 Arr의 0번째에 1의 값 저장
> >  Arr[idx] = 1	# 배열 Arr의 idx번째에 1의 값 저장
> >  ```
> >
> > 

---





<br>

<br> 

## 정렬

### 정렬

>  #### 정렬
>
> > - 2개 이상의 자료를 특정 기준에 의해 재배열 하는 것
> > - 오름차순(ascending): 작은 값부터 큰 값
> > - 내림차순(descending): 큰 값부터 작은 값
>
>  #### 정렬의 종류
>
> > - 버블 정렬 (Bubble Sort)
> > - 카운팅 정렬 (Counting Sort)
> > - 선택 정렬 (Selection Sort)
> > - 퀵 정렬 (Quick Sort)
> > - 삽입 정렬 (Insertion Sort)
> > - 병합 정렬 (Merge Sort)



<br>



### 버블 정렬 (Bubble Sort)

>  #### 버블 정렬
>
> > - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
>
> #### 정렬 과정
>
> > - 첫 번째 원소부터 인접한 원소끼리 크기를 비교하며 자리를 교환
> > - 맨 마지막 자리까지 교환하여 한 단계가 끝나면 가장 큰(작은) 원소가 마지막 자리로 정렬
>
>  #### 시간 복잡도
>
> > - O(n^2)
>
>  #### 예시 코드
>
> >  ```python
> >  def Bubble_Sort(a, N):	# a: 정렬할 List, N: 리스트의 길이
> >      for i in range(N-1, 0, -1):
> >          for j in range(i):
> >              if a[j] > a[j+1]:
> >                  a[j], a[j+1] = a[j+1], a[j]
> >  ```



### 카운팅 정렬 (Counting Sort)

>  #### 카운팅 정렬
>
> > - 정렬해야 하는 항목이 몇 개인지 세어 선형 시간에 정렬하는 효율적인 알고리즘
> > - 정수 혹은 정수로 표현 가능한 자료만 가능
> > - 카운트를 위한 충분한 공간을 위해 집합 내 가장 큰 정수가 필요
>
>  #### 정렬 과정
>
> > 1. Data의 각 정수 항목 x들의 발생 회수(count)를 센다.
> > 2. 카운트를 각 정수 항목 x가 인덱스가 되는 배열 counts에 새로 저장한다.
> > 3. 누적된 카운트를 저장한다.
> > 4. Data의 정수 항목 x에 하나씩 접근하여 누적 카운트 개수를 찾는다.
> > 5. 누적 카운트를 1 감소 시킨다.
> > 6. 누적 카운트를 인덱스로 갖는 새로운 정렬된 배열에 x를 저장한다.
>
> #### 시간 복잡도
>
> > - O(n + k) : n은 리스트 길이, k는 정수의 최대값
>
>  #### 예시 코드
>
> > ```python
> > def Counting_Sort(A):
> >     # A [] -- 정렬할 배열
> >     # B [] -- 정렬된 배열
> >     # C [] -- count 배열
> >     
> >     k = max(A)
> >     B = [0] * len(A)
> >     C = [0] * (k+1)
> >     
> >     for i in range(0, len(A)):
> >     	C[A[i]] += 1
> >        
> >     for i in range(1, len(C)):
> >         C[i] += C[i-1]
> >        
> >     #for i in range(len(B)-1, -1, -1)
> >     for i in range(len(B)):
> >         C[A[i]] -= 1
> >         B[C[A[i]]] = A[i]
> >     
> >     return B
> >         
> > ```
> >
> > 



<br>

<br> 

## 접근 방법

### 완전 검색 (Exaustive Search)

> - 모든 경우의 수를 나열하여 확인하는 기법
> - Brute-force 혹은 grenerate-and-test 기법이라고도 불림
> - 경우의 수가 작을 때 유용



### 탐욕(Greedy) 알고리즘

> - 최적 해를 구하는데 사용되는 근시안적 방법
> - 여러 경우 중 하나를 결정해야 할 때, 최적이라고 생각되는 것을 선택해 나가는 방식
> - 각 선택은 지역적으로는 최적일 ㅅ수 있으나, 선택들을 계속 수집하여 나온 해답이 최적이라는 보장은 없다.
> - 머릿속에 떠오르는 생각을 검증 없이 구현하는 접근법