# List

[알고리즘](#알고리즘)

[배열](#배열)

[정렬](#정렬)

[접근 방법](#접근-방법)





<br>





## 알고리즘

### Algorithm

> - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
>
> - 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
>
> - 기준
>
>   > - 정확성
>   > - 작업량
>   > - 메모리 사용량
>   > - 단순성
>   > - 최적성



<br>



### 시간 복잡도

> #### 시간 복잡도(Time Complexity)
>
> > - 실제로 걸리는 시간을 측정
> > - 실행되는 명령문의 개수(연산의 횟수)를 계산 
>
> #### 빅-오(O) 표기법
>
> > - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만 표시
> >
> > - 계수(Coefficient)는 생략
> >
> >   ```markdown
> >   O( 5n + 4 ) = O( 5n ) = O( n )
> >   O( 5n^2 + 4n + 3 ) = O( n^2 )
> >   O( 5 ) = O ( 1 )
> >   ```
> >
> > - 시간 복잡도의 종류
> >
> >   - O(1)
> >   - O(logn)
> >   - O(n)
> >   - O(nlogn)
> >   - O(n^2)
> >   - O(2^n)
> >   - O(n!)





---



<br>

<br> 



## 배열

### 배열

> - 일정한 자료형의 변수를 하나의 이름으로 열거하여 사용
> - 다수의 변수 선언 가능 및 다양한 작업 가능



<br>



### 1차원 배열

>  #### 선언
>
>  >  ```python
>  >  Arr = list()
>  >  Arr = []
>  >  
>  >  Arr = [1, 2, 3]
>  >  Arr = [0] * 10
>  >  ```
>
>  #### 접근
>
>  >  ```py
>  >  Arr[0] = 1  	# 배열 Arr의 0번째에 1의 값 저장
>  >  Arr[idx] = 1	# 배열 Arr의 idx번째에 1의 값 저장
>  >  ```
>  >



<br>



### 2차원 배열

>  ### 선언
>
> >  ```python
> >  arr = [[1, 2, 3, 4], [5, 6, 7, 8]]
> >  arr = list([0]*N for _ in range(M)) # M×N 행렬
> >  
> >  N = int(input()) # 열 개수
> >  arr = [list(map(int, input().split())) for _ in range(N)]
> >  ```
> >
> > 

---





<br>

<br> 

## 정렬

### 정렬

>  #### 정렬
>
> > - 2개 이상의 자료를 특정 기준에 의해 재배열 하는 것
> > - 오름차순(ascending): 작은 값부터 큰 값
> > - 내림차순(descending): 큰 값부터 작은 값
>
>  #### 정렬의 종류
>
> > - 버블 정렬 (Bubble Sort)
> > - 카운팅 정렬 (Counting Sort)
> > - 선택 정렬 (Selection Sort)
> > - 퀵 정렬 (Quick Sort)
> > - 삽입 정렬 (Insertion Sort)
> > - 병합 정렬 (Merge Sort)



<br>



### 버블 정렬 (Bubble Sort)

>  #### 버블 정렬
>
> > - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
>
> #### 정렬 과정
>
> > - 첫 번째 원소부터 인접한 원소끼리 크기를 비교하며 자리를 교환
> > - 맨 마지막 자리까지 교환하여 한 단계가 끝나면 가장 큰(작은) 원소가 마지막 자리로 정렬
>
>  #### 시간 복잡도
>
> > - O(n^2)
>
>  #### 예시 코드
>
> >  ```python
> >  def Bubble_Sort(a, N):	# a: 정렬할 List, N: 리스트의 길이
> >      for i in range(N-1, 0, -1):
> >          for j in range(i):
> >              if a[j] > a[j+1]:
> >                  a[j], a[j+1] = a[j+1], a[j]
> >  ```



### 카운팅 정렬 (Counting Sort)

>  #### 카운팅 정렬
>
>  > - 정렬해야 하는 항목이 몇 개인지 세어 선형 시간에 정렬하는 효율적인 알고리즘
>  > - 정수 혹은 정수로 표현 가능한 자료만 가능
>  > - 카운트를 위한 충분한 공간을 위해 집합 내 가장 큰 정수가 필요
>
>  #### 정렬 과정
>
>  > 1. Data의 각 정수 항목 x들의 발생 회수(count)를 센다.
>  > 2. 카운트를 각 정수 항목 x가 인덱스가 되는 배열 counts에 새로 저장한다.
>  > 3. 누적된 카운트를 저장한다.
>  > 4. Data의 정수 항목 x에 하나씩 접근하여 누적 카운트 개수를 찾는다.
>  > 5. 누적 카운트를 1 감소 시킨다.
>  > 6. 누적 카운트를 인덱스로 갖는 새로운 정렬된 배열에 x를 저장한다.
>
>  #### 시간 복잡도
>
>  > - O(n + k) : n은 리스트 길이, k는 정수의 최대값
>
>  #### 예시 코드
>
>  > ```python
>  > def Counting_Sort(A):
>  >  # A [] -- 정렬할 배열
>  >  # B [] -- 정렬된 배열
>  >  # C [] -- count 배열
>  > 
>  >  k = max(A)
>  >  B = [0] * len(A)
>  >  C = [0] * (k+1)
>  > 
>  >  for i in range(0, len(A)):
>  >  	C[A[i]] += 1
>  > 
>  >  for i in range(1, len(C)):
>  >      C[i] += C[i-1]
>  > 
>  >  for i in range(len(B)-1, -1, -1):
>  >      C[A[i]] -= 1
>  >      B[C[A[i]]] = A[i]
>  >  # for i in range(len(B)):를 쓰지 않는 이유는 stable sort를 위함
>  > 
>  >  return B
>  > 
>  > ```
>  >
>  > 



<br>



### 선택 정렬

>  #### 선택 정렬
>
> > - 남은 배열에서 최솟값을 찾아 남은 배열의 맨 앞과 교환한다.
> > - 배열의 수가 적을 경우 효과적이다.
> > - k번째로 작은 수, 혹은 큰 수를 찾을 때 사용할 수 있다.
>
> #### 정렬 과정
>
> > 1. 리스트에서 최솟값을 찾는다.
> > 2. 리스트의 맨 앞의 값과 교환한다.
> > 3. 정렬되지 않은 남은 리스트에서 최솟값을 찾는다.
> > 4. 정렬되지 않은 남은 리스트의 맨 앞의 값과 교환한다.
> > 5. 3,번 4번 반복 
>
> #### 시간 복잡도
>
> > - O(n^2)
>
>  #### 예시 코드
>
> >  ```python
> >  def selectionSort(a, N):
> >      # 0 ~ N-1까지. N번째는 혼자 남으므로 정렬할 필요가 없다.
> >      for i in range(N-1):
> >          # 리스트의 시작점
> >          min_idx = i
> >          for j in range(i+1, N):
> >              # 최솟값의 인덱스를 찾는다.
> >              if a[min_idx] > a[j]:
> >                  min_idx = j
> >          # 최솟값을 시작점과 교환
> >          a[i], a[min_idx] = a[min_idx], a[i]
> >  ```
> >
> > 



<br>



### 퀵 정렬

> #### 퀵 정렬
>
> > - 평균적으로 가장 빠른 정렬	
>
> #### 정렬과정
>
> > 1. 가운데 값을 pivot으로 둔다.
> > 2. L이 오른쪽으로 이동하면서 피봇보다 크거나 같은 원소를 찾고
> > 3. R이 왼쪽으로 이동하며서 피봇보다 작은 원소를 찾는다.
> > 4. 찾은 값들끼리 자리를 바꾼다. (피봇보다 큰 값은 피봇 오른쪽에, 작은 값은 왼쪽에 두는 것.)
> > 5. L과 R이 만나면 (L+1까지 R이 오면) 피봇과 만난 장소를 바꾸고 해당 위치를 고정시킨다. 
> > 6. 고정된 피봇들 사이의 범위에서 위의 과정을 반복한다.
>
> #### 시간 복잡도
>
> > - 평균 O(nlogn)
> > - 최악의 경우 O(n^2)
>
> #### 예시 코드
>
> >  ```python
> >  def quickSort(a, begin, end):
> >      if begin < end:
> >          p = partition(a, begin, end)
> >          quickSort(a, begin, p-1)
> >          quickSort(a, p+1, end)
> >  
> >  def partition (a, begin, end):
> >      pivot = (begin + end) // 2
> >      L = begin
> >      R = end
> >      while L < R:
> >          while(L<R and a[L] < a[pivot]):
> >              L += 1
> >          while(L<R and a[R] >= a[pivot]):
> >              R -= 1
> >          if L < R:
> >              if L == pivot:
> >                  pivot = R
> >                  a[L], a[R] = a[R], a[L]
> >      a[pivot], a[R] = a[R], a[pivot]
> >      return R
> >              
> >          
> >  ```
> >
> > ```python
> > def quick_sort(array):
> >     # 리스트가 하나 이하의 원소만을 담고 있다면 종료
> >     if len(array) <= 1:
> >         return array
> >     pivot = array[0]  # 피벗은 첫 번째 원소
> >     tail = array[1:]  # 피벗을 제외한 리스트
> > 
> >     # 오름차순
> >     # left_side = [x for x in tail if x <= pivot]  # 분할된 왼쪽 부분
> >     # right_side = [x for x in tail if x > pivot]  # 분할된 오른쪽 부분
> >     
> >     # 내림차순
> >     left_side = [x for x in tail if x > pivot]  # 분할된 왼쪽 부분
> >     right_side = [x for x in tail if x <= pivot]  # 분할된 오른쪽 부분
> > 
> >     # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고 전체 리스트 반환
> >     return quick_sort(left_side) + [pivot] + quick_sort(right_side)
> > 
> > 
> > print(quick_sort(array))
> > ```
> >
> > 



<br>

<br> 

## 접근 방법

### 완전 검색 (Exaustive Search)

> - 모든 경우의 수를 나열하여 확인하는 기법
> - Brute-force 혹은 grenerate-and-test 기법이라고도 불림
> - 경우의 수가 작을 때 유용



### 탐욕(Greedy) 알고리즘

> - 최적 해를 구하는데 사용되는 근시안적 방법
> - 여러 경우 중 하나를 결정해야 할 때, 최적이라고 생각되는 것을 선택해 나가는 방식
> - 각 선택은 지역적으로는 최적일 ㅅ수 있으나, 선택들을 계속 수집하여 나온 해답이 최적이라는 보장은 없다.
> - 머릿속에 떠오르는 생각을 검증 없이 구현하는 접근법





## 검색 방법

#### 정렬되어 있지 않은 경우

> - 첫 번째 원소부터 순서대로 끝까지 검사한다.
> - 동일한 값을 찾으면 인덱스를 반환한다.
> - 찾고자 하는 원소의 순서가 늘어나면 비교 횟수도 늘어난다.
> - 시간복잡도: O(n)



### 정렬되어 있는 경우

>  #### 오름차순 / 내림차순 검색
>
> > - 자료를 순차적으로 검색하며, 동일한 값을 찾으면 더 이상 검색하지 않고 검색 종료
> > - 찾고자 하는 원소의 인덱스가 여러개라도 검색 낭비가 적다.
>
> #### 이진 검색
>
> > - 정렬된 상태에서 시작
> > - 자료의 가운데부터 절반씩 검색 범위를 줄이면서 검색
> > - 시작점과 종료점을 바꾸면서 검색
> > - 자료에 삽입, 삭제가 있을 경우, 배열을 정렬상태로 유지하는 작업 필요